##
# Setup File Template.
# Generated by ATEGen (Version 1.6.4-1 [linux x86_64] 28-Nov-2015).
# (c) Copyright 1998-2016 Test Insight Ltd.
##

##############################
# Input File Definition
# Notes:
# - STIL, WGL, TDL91 & AIF file types are supported
# - file type is determined automatically by content (except AIF)
# - force file type by setting input_file_type value below (automatic recognition by extention is disabled)
##
input_file_type = ''     # valid values: STIL WGL TDL AIF (optional if not AIF)

##############################
# Unify WFT periods
# Modify all WFTs to use identical period
#  - scan all WFTs, find GDC of all periods (base period)
#  - split WFTs to use only base period
# Possible values: 0 (disable option) and 1 (enable option), default is 0
##
unify_periods = 0
#
# Cycle boundary edge placement ( only applicable when unify_periods is enabled )
# Valid values:
# 'next_vector' - insert edge at position 0 of the next vector (default)
# 'curr_vector' - append edge to to the current vector
##
#unify_periods_boundary_edge_placement = 'next_vector'                          # global edge placement
#unify_periods_signal_boundary_edge_placement = { 'Sig1' : 'curr_vector', ... } # signal-based edge placement

##############################
# Mask failures file
# If the parameter is not empty, mask failures in STIL pattern
#  - read vectors, mask failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#mask_failing_signals = 'path'

##############################
# Fix failures file
# If the parameter is not empty, fix failures in STIL pattern
#  - read vectors, fix failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#fix_failing_signals = 'path'

##############################
# Keep intermediate STIL files (Optional)
keep_stil_files = 0

################################
# 93000 AIF Reader Configuration
######

# Specifies AIC file (Mandatory)
aic_file = ''

# Specifies DVC file (Mandatory)
dvc_file = ''

# Specifies 93000 Pin Configuration file (Optional, may be defined in AIC)
pins_file = ''

# Specifies default AVC files directory (Optional, may be defined in AIC)
avc_dir = ''

##############################
# WGL Reader Configuration
######

# Scan input padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_in_padding = '0'

# Scan output padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_out_padding = 'X'

# If true, scanchain inverters are ignored while processing scan data. (Optional)
# Valid values are: [01] (false,true)
wgl_skip_inverters = 0


# Purge unused timeplates. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused timeplates from the output file, if true.
wgl_purge_unused_timeplates = 1

# Purge unused waveforms. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused waveforms from the output file, if true.
# Note that unused timeplates will be removed too.
wgl_purge_unused_waveforms = 1

# Export WGL scanchains into STIL ScanStructures. (Optional)
# Valid values are: [01] (false,true)
wgl_export_scanchains = 0

# Add Drive-Off event. (Optional)
# Turn driver off in compare waveforms, if missing
# Valid values are: [01] (false,true)
wgl_add_drive_off = 1

##############################
# TDL Reader Configuration
######

# Enable/diable scan structures import. (Optional, default = 1)
tdl_import_scan_structures = 1

# Purge unused timing data. (Optional)
# Valid values are: [01] (false,true)
# Remove any 'unused' timing timplates/waveforms from the output file, if true.
tdl_purge_unused_timing = 0

# Drive off position. (Optional, default = 0ns)
# Valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
tdl_drive_off_position = ''

# Signal drive off position. (Optional)
# Pin to position map
# Position valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
# tdl_signal_drive_off_position = { 'data' : '2ns'}

##############################
# ATE Generator Configuration
######

# Target Platform.(Mandatory)
# Valid values depend on configuration file installed.
# Currently available targets:
#  "93000DD"
#  "93000SD"
#  "EagleEVD"
#  "TeradyneUltraFlex"
target = '93000DD'

# Additional pattern comment.
# This comment will be added to the first vector of all patterns.
pattern_comment = ''

# Default definition files.(Optional)
# Files containing STIL blocks with default definitions.
default_definitions = []

# External data files.(Optional)
# Files containing additional STIL blocks.
external_data_files = []

# STIL PatternExec name. (Optional)
# First one is used if not specified.
stil_pattern_exec = ''

# Pattern naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_pattern_name = 0, use STIL Pattern name when generating pattern.
# If stil_file_name_as_pattern_name = 1, use STIL File name.
stil_file_name_as_pattern_name = 1

# Project naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_project_name = 0, use project_name parameter as a base name for signal, timing, levels etc. files.
# If stil_file_name_as_project_name = 1, use STIL File name.
stil_file_name_as_project_name = 1

# Use STIL file name as WFT prefix ( Optional, default = 0 ).
stil_file_name_as_wft_prefix = 1

# Label suffix flag ( Optional, default =  ).
# Add custom suffix to all pattern and burst names
label_suffix = ""

# Set ScanIn signals padding value ( Optional, default = '0' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanin = '0'

# Set ScanOut signals padding value ( Optional, default = 'X' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanout = 'X'

# Alternative WFC Map. (Optional)
# Define alternative WFC Map for data assignment conflict resolution.
# This map will only be used if native STIL WFCMap fails to resolve a conflict.
# Example: { '0X' : '0', '1X' : '1', ...   }
stil_wfc_map = {
    }

# Global STIL Action Map. (Optional)
# Allows users to globally remap STIL action states in Timing section.
# Example: { 'Z': 'X', 'P': D' }
stil_action_map = { }

# Exit with an error if signal is assigned the value twice in the same vector
# and WFCMap is either absent or does not resolve the ambiguity. (Optional, default is 0).
error_on_2_state_ambiguity = 0

# Force edge strobe ( Optional, default = 0 ).
# If set to 1, STIL window compare events will be replaced with edge compare.
# If set to 0, STIL window compare events will be kept.
force_edge_strobe = 1

# STIL resource tags handling configuration ( Optional, default = 0 ).
# If ignore_stil_rtags = 1, STIL <rtag> data will be stored and possibly used ( target dependent ).
# If ignore_stil_rtags = 0, STIL <rtag> data will be ignored.
ignore_stil_rtags = 0

# STIL ScanStructures handling configuration ( Optional, default = 1 ).
# If ignore_scan_structures = 0, STIL ScanStructures data will be stored and possibly used ( target dependent ).
# If ignore_scan_structures = 1, STIL ScanStructures data will be ignored.
ignore_scan_structures = 1

# STIL Pseudo Signals handling configuration ( Optional, default = 1 ).
# If stil_ignore_pseudo_signals = 0, Signals of type Pseudo will be processed similar to other signals.
# If stil_ignore_pseudo_signals = 1, Signals of type Pseudo will be ignored.
stil_ignore_pseudo_signals = 1


# Output directory. (Optional, default = 'output')
workdir = 'output'

# Project name. (Optional, default = 'project' )
# Serves as a base name for all named TP blocks
project_name = ''

# Pattern signals definition. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Define a reduced set signals to be used in the pattern only.
# Signals not in the list will still appear in 'workspace' portion
# of the test program.
# Example: [ 'sig1', 'sig2', 'sigN' ]
pattern_signals = [  ]

# Define global signals set. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Only specified signals will be passed to the target test program.
# This parameter is mutually exclusive with 'exclude_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
include_signals = [  ]

# Define set of signals to exclude from target test program. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Specified signals will be completely removed from the target test program.
# This parameter is mutually exclusive with 'include_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
exclude_signals = [  ]

# Rename signals. (Optional)
# Define a mapping between simulation signals and target ATE pins.
# Any signals not specified in the map will use original names.
# Signal groups are not allowed.
# Note: this will not affect any signal-related configuration settings above,
#       i.e. all signal-related setup variables should always refer to the original signal names.
# Example: { 'signal_name1' : 'ATE_signal_name1', 'signal_name2' : 'ATE_signal_name2', ...   }
rename_signals = {

}

# Stop on uninitialized signals ( Optional, default = 0 ).
stop_on_uninitialized_signals = 0

# Timing Map. (Optional)
# Define STIL timing mapping in order to fit to tester restrictions.
# For example, map all dual compare waveforms to single compare.
# By default all inputs with undefined value are mapped to 0.
# The following wildcards can be used:
#     I for input  actions - D, U, P, A, B
#     O for output actions - H, L, X, x, T, V, l, h, t, v
#     . for any action.
# Example: { 'N' : 'D' }
timing_map = {
    'N': 'D',
    }

# Signal Timing Map. (Optional)
# Define STIL timing mapping for specific signals.
# By default global timing map is used.
# Wildcards can be used (same as in Timing Map).
# Example: { 'STIL_signal_name1' : { 'UDU' : '-DU' , 'DUD' : '-UD' , ... } , ... }
signal_timing_map = {
    }

# Sequence Map. (Optional)
# Define pattern states mapping for specific signals.
# Valid values are 0/1/Z/L/H/T/X.
# Example: { 'signal_name1' : { '010' : '111' , 'LHL' : 'LXL' , ... } , ... }
sequence_map = {
    }

# Equation Based Timing. (Optional, default = 1)
# Generate equation (Spec) based timing if original timing only used absolute values without any Spec definition.
# For example, equation specified as 10ns (when period is 100ns)
# will become 0.1*per_100, where per_100 is a new Spec variable.
equation_based_timing = 1

# Optimize Spec Variables in Equation Based Timing Mode. (Optional, default = 1)
# If optimize_equation_based_timing_vars = 1, a spec variable for each unique WFT period will be generated (e.g. per_100).
# If optimize_equation_based_timing_vars = 0, a spec variable for each WFT will be generated (e.g. per_SHIFT, per_CAPTURE).
optimize_equation_based_timing_vars = 1

# Define Muxed Signals List.(Optional)
# Both signals and signal groups alowed ( groups are expanded ).
# Wildcards allowed ( only '?' and '*' supported ).
# Second signal name will be composed as [signal name][mux_signal_suffix].
# Note: Second (muxed) signal must not exist in original signals list.
# Example: [ 'sig1', 'sig2', 'sigN' ]
generate_mux_signals = [  ]

# Muxed signal suffix. (Optional, default = '_mux')
# Used in conjunction with 'generate_mux_signals' to form second signal name.
mux_signal_suffix = '_mux'

# Vector Comment Source. ( Optional, default = ['Annotation'] )
# Vector comment is placed before the vector call in the vector comment field, as follows:
# 'Annotation' use the content of the annotation block ( Ann {* .. *} )
# 'C' use the content of the C comment ( /* .. */ )
# 'C++' use the content of the C++ comment ( // ... )
# 'Macro' Places name of Macro called in the vector comment field
# 'Procedure' Places name of Procedure called in the vector comment field.
# 'Scan Instance' Places the scan instance in the vector comment field (i.e. the number of times the Shift
#                 statement has been called in the context of a Pattern block)
# 'Label' Places STIL Label name in the vector comment field
#  Note: more the one comment type may be defined, as follows: [ 'C', 'C++', 'Macro' ]
vector_comment_source = [ 'Annotation' ]

# Same line comment handling. ( Optional, default = 0 )
# If set to 1, attach comment to the vector at the same line.
# If set to 0, attach it to the next vector
same_line_comment = 0

# Define set of scan cells to mask. (Optional)
# Example: [ 'cell1', 'cell2', 'cellN' ]
mask_scan_cells = [  ]

# Define set of scan chains to mask. (Optional)
# Example: [ 'chain1', 'chain2', 'chainN' ]
mask_scan_chains = [  ]

# Define set of scan signals to mask. (Optional)
# Example: [ 'sig1', 'sig2', 'sigN' ]
mask_scan_signals = [  ]

# Scan pattern start label. (Optional, default = '')
# Generation of scan pattern will start from this label.
# If empty, generation starts at the start of the pattern.
scan_pattern_start = ''

# Scan pattern stop label. (Optional, default = '')
# Generation of scan pattern will stop at this label.
# If empty, generation stops at the end of the pattern.
scan_pattern_stop = ''

# Skip non-indexed multibit events. (Optional, default = 1)
# In multibit waveforms, use only indexed events when creating wfc sequence.
# For example, waveform "eE {'0ns' D/U[0]; '2.5ns' Z; }"
# should be referred in pattern as e or E (if parameter is set to 1).
# or as ee or Ee (if parameter is set to 0).
skip_nonindexed_events = 1

# Define set of user keywords to be processed. (Optional)
# The following keywords can be specified:
# 'ShiftIncrement': similar to Shift, but if contains multiple vectors, data is shifted after each vector
# 'InfiniteLoop'  : handled as non-looped sequence of vectors
# Example: [ 'kwd1', 'kwd2' ]
process_user_keywords = [  ]

# Generate pins ( Optional, default = 1 ).
# If set to 1, ATE pin definitions will be generated.
# If set to 0, ATE pin generation will be skipped ( target dependent ).
generate_pins = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE timing definitions will be generated.
# If set to 0, ATE timing generation will be skipped ( target dependent ).
generate_timing = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE DC levels definitions will be generated.
# If set to 0, ATE DC levels generation will be skipped ( target dependent ).
generate_levels = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE patterns will be generated.
# If set to 0, ATE patterns generation will be skipped ( target dependent ).
generate_patterns = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE workspace will be generated.
# If set to 0, ATE workspace generation will be skipped ( target dependent ).
generate_workspace = 1

############################
# Virtual Signal Generation
#

# Define virtual signals ( optional ).
#  Attributes:
#   name:	 virtual signal name ( mandatory, must be unique )
#   type:	 virtual signal type ( optional, one of [ In | Out | InOut ] )
#   opcode:	 virtual signal operator ( mandatory )
#     'Fixed':            Fixed state signal ( arg1 = state [DUZLHXT], arg2 = time )
#     'Copy':             Copy reference signal ( arg1 = ref. signal name )
#     'Not':              Copy reference signal, inverting states ( arg1 = ref. signal name )
#   args:	 operator attributes ( depend on 'op' selected )
#
# virtual_signals = [ 
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] },
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] } ...
# ]

##################################
# 93000DD flags 
######

# SmarTest revision number
dd_smartest_version = "7.1.4"

# Tester model selection. Possible values are:
# 'PS400','PS800', 'PS3600'
dd_tester_model = 'PS800'

# Xmode combinations file
dd_combinations_file = None

# Use absolute paths in EQFS commands
# to load timing and level files.
dd_absolute_paths = 0

# Device cycle naming customization.
# The keys are <WFT>_<WFC> strings,
# the values are user-defined strings.
dd_dcdf_remapping = {}

# Device cycle naming for specific signals
# The keys are signal names, the values are
# tables with <WFT>_<WFC> strings as keys, mapped
# to user-defined strings. For example, to map H to h, L to l 
# for signal clock in WFT T1 and the same for data:
# dd_dcdf_signal_remapping = { 'clock' : { 'T1_H' : 'h','T1_L':'l' }, 
#                              'data'  : { 'T1_H' : 'h','T1_L':'l' } }
dd_dcdf_signal_remapping = {} 

# Wavetable naming customization.
# The keys are <WFT1>_<WFT2>_... strings for regular setups,
# and <WFT1>_<WFT2>_...<PORT> strings for multiport setups,
# the values are user-defined strings.
dd_wavetbl_remapping = {}

# Device vector variable naming for digital capture
# The keys are the original vector variable names,
# mapped to user-defined strings.
dd_dcap_vector_variable_rename = {}

# Compress patterns with GZip.
dd_gzip_patterns = 1

# Compress identical vectors to single vector loops
dd_repeat_compression = 1

# When repeat compression is on: compress identical vectors to single vector loops althogh they don't have the same comment.
# The different comments from the vectors will be placed before the created loop.
dd_repeat_compression_ignore_comments = 1

# Keep WFC ordering as in source STIL file.
dd_keep_wfc_order = 1

# This option is reserved for future use 
# and should not be modified
dd_max_vector_buffer = 158928

# Data size for BCMT vector comment command
dd_comment_max_size  = 640000

# Error out on comments violating SmarTest limit (depends on SmarTest version)
# By default long comments are truncated and a warning is generated
dd_error_on_long_comments = 0

# Xmode aware vector comment mode. If selected, the following behavior will be used
# 1. If all comments for all sub-Xmode vectors are identical generate only single comment
#    For instance, Xmode = 2:
#    STIL:
#      V {} // my comment 1
#      V {} // my comment 1
#    93K comment:
#      "my comment 1"
# 2. Each sub-Xmode comment is delimited by "|" sign
dd_xmode_aware_comments = 0

# Loops smaller than repeat_break value
# will be flattened to save tester resources.
# By default the loop will be flattened if
# (loop_size * loop_count + 6)/7 < 1 + (loop_size + 6)/7
dd_repeat_break = None

# Loop expansion
# Expand original loops in source STIL files
dd_expand_loops = 0

# Generate ascii pattern (AVC) and TMF files
dd_generate_ascii_pattern = 1

# Generate ascii TMF file only
dd_generate_ascii_tmf = 0

# Add comments to timing files.
dd_tim_comments = 0

# Use EQFS commands in timing and level files.
dd_use_eqfs = 0

# Use STIL resource tags to generate device
# cycle names.
dd_use_restags = 1

# Skip signal groups not found in STIL
dd_skip_unused_signal_groups = 0

# Allow unify periods
dd_allow_unify_periods = 0

# Group definitions in timing files.
dd_use_tim_groups = 1

# Use pin names only in timing files
dd_pin_based_tim = 1

# Exclude pins from grouping in timing files
dd_tim_group_exclude_pins = []

# Pattern memory type
# Valid pattern memory types are:
#  'VM'    for SmarTest versions until 7.0.0
#  'SM'    for all SmarTest versions
#  'SHMEM' for SmarTest versions 7.0.1 and higher
#  'auto'  for automatic selection of memory type according to 
#          SmarTest version
dd_pattern_memory_type = 'SM'

# This option is reserved for future use 
# and should not be modified
dd_use_vecc = 1

# Apply Xmode factor to all patterns
dd_xmode_factor = 1

# Create all possible Xmode combinations in timing
# (instead of only actual timing combinations in the patterns)
# Use with caution - may lead to waveformtable overflow
dd_xmode_all_cmb = 0

# Allow addition of new waveforms in combinations file
dd_combinations_allow_new_waveforms = 1

# Pad last xmode vector 
# Padding is performed when the number of vectors in not evenly divisible by xmode factor
# and if the last waveform contains only drive actions.
dd_pad_xmode_vectors = 0

# Edge optimization
dd_optimize_receive_edges = 1
dd_optimize_drive_edges = 1

# Allow wavetable merge, to optimize tester resources
dd_allow_wavetbl_merge = 0

# Generate single port timing, if possible
dd_single_port_timing = 0

# Create all_inputs and all_outputs signal groups for debug purposes
dd_auto_create_signal_groups = 0

# Use specified channel mapping
dd_use_channel_mapping = None

# Import model file
dd_use_model_file = None

# Strict mode - will not create code that is not loadable
dd_strict_mode = 0

# DC levels generation - allow default values
dd_allow_default_levels = 1

# Print information about signals using default levels
dd_default_levels_summary = 0

# Exclude pins from grouping in level files
dd_levels_group_exclude_pins = []

# Use MHz frequency in AC specs
dd_use_mhz_specs = 0

# Keep unused specsets
dd_keep_all_specsets = 0

# Keep unused AC and DC variables
dd_keep_spec_variables = 0

# Split min, typ and max AC and DC specs into separate specsets
dd_create_min_max_typ_tests = 0

# Print full incremental mode report
dd_full_incremental_log = 0

# Create statemapping
dd_create_statemapping = 0

# Statemapping is based on selected xmode
dd_xmode_based_statemapping = 1

# Statemapping selector name. 
# The default is the value of project_name parameter
dd_statemap_selector = ''

# Create separate ports for scan and non-scan signals
dd_scan_multiport = 0

# Scan diagnostics
dd_generate_vmap = 0

# HVM support
dd_generate_hvm = 0

# HVM vector and cycle information
dd_hvm_cycle_info = 0

# Support for Synopsys TetraMAX scan diagnostics
dd_tetramax_scan_diagnostics = 0

# Yield learning (Nautilus) support
dd_yield_learning = 0

# Yield learning - scan structures selection
dd_yield_learning_scan_structures = None

# Yield learning - scan structures domain name used in protocol file
dd_yield_learning_scan_domain = None

# Yield learning - skip flops (scan cells) names
dd_yield_learning_skip_flops = 0

# Support multiple clock domains
dd_generate_clksets = 0

# Print vector usage summary for each binary pattern
dd_vector_memory_summary = 0

# Allow match loops with number of vectors not aligned to xmode
dd_allow_nonaligned_match_loops = 0

# Testmethod attributes

# Testmethod mode, may be 'utm','classic' or 'functions'
# The default is 'functions' 
dd_testmethod_mode = 'functions'

# Testmethod name, used in classic mode only
dd_testmethod_name = ''

# Testmethod parameters, used in UTM and classic modes
# By default there are no parameters
dd_testmethod_params = ''

# Testmethod limits, used in UTM and classic modes
# By default there are no limits
dd_testmethod_limits = ''

# Testmethod class, used in UTM and classic modes
# The default suits only UTM mode, please replace is to 'functional' for classic mode
dd_testmethod_class = 'ac_tml.AcTest.FunctionalTest'

# Digital capture mode
# Possible values are:
# 'std_selective','HRPF'
dd_digital_capture_mode = 'std_selective'

# Digital capture resolution
# Possible values are:
# 'std', 'double'
dd_digital_capture_res = 'std'

