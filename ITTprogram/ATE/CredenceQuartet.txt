##
# Setup File Template.
# Generated by ATEGen (Version 1.9.1 [linux x86_64] 31-Jan-2018).
# (c) Copyright 1998-2018 Test Insight Ltd.
##

##############################
# Input File Definition
# Notes:
# - STIL, WGL, TDL91 & AIF file types are supported
# - file type is determined automatically by content (except AIF)
# - force file type by setting input_file_type value below (automatic recognition by extention is disabled)
##
input_file_type = ''     # valid values: STIL WGL TDL AIF (optional if not AIF)

##############################
# Unify WFT periods
# Modify all WFTs to use identical period
#  - scan all WFTs, find GDC of all periods (base period)
#  - split WFTs to use only base period
# Possible values: 0 (disable option) and 1 (enable option), default is 0
##
unify_periods = 0
#
# Cycle boundary edge placement ( only applicable when unify_periods is enabled )
# Valid values:
# 'next_vector' - insert edge at position 0 of the next vector (default)
# 'curr_vector' - append edge to to the current vector
##
#unify_periods_boundary_edge_placement = 'next_vector'                          # global edge placement
#unify_periods_signal_boundary_edge_placement = { 'Sig1' : 'curr_vector', ... } # signal-based edge placement

##############################
# Mask failures file
# If the parameter is not empty, mask failures in STIL pattern
#  - read vectors, mask failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#mask_failing_signals = 'path'

##############################
# Fix failures file
# If the parameter is not empty, fix failures in STIL pattern
#  - read vectors, fix failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#fix_failing_signals = 'path'

##############################
# Keep intermediate STIL files (Optional)
keep_stil_files = 0

################################
# 93000 AIF Reader Configuration
######

# Specifies AIC file (Mandatory)
aic_file = ''

# Specifies DVC file (Mandatory)
dvc_file = ''

# Specifies 93000 Pin Configuration file (Optional, may be defined in AIC)
pins_file = ''

# Specifies default AVC files directory (Optional, may be defined in AIC)
avc_dir = ''

##############################
# WGL Reader Configuration
######

# Scan input padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_in_padding = '0'

# Scan output padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_out_padding = 'X'

# If true, scanchain inverters are ignored while processing scan data. (Optional)
# Valid values are: [01] (false,true)
wgl_skip_inverters = 0


# Purge unused timeplates. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused timeplates from the output file, if true.
wgl_purge_unused_timeplates = 1

# Purge unused waveforms. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused waveforms from the output file, if true.
# Note that unused timeplates will be removed too.
wgl_purge_unused_waveforms = 0

# Export WGL scanchains into STIL ScanStructures. (Optional)
# Valid values are: [01] (false,true)
wgl_export_scanchains = 0

# Add Drive-Off event. (Optional)
# Turn driver off in compare waveforms, if missing
# Valid values are: [01] (false,true)
wgl_add_drive_off = 1

##############################
# TDL Reader Configuration
######

# Enable/diable scan structures import. (Optional, default = 1)
tdl_import_scan_structures = 1

# If enabled, generate CLOCK signal as 2-edge (RH/RL) instead of 3-edge (SBH/SBL),
# eliminating the first edge. (Optional, default = 0)
tdl_2_edge_clocks = 0

# Purge unused timing data. (Optional)
# Valid values are: [01] (false,true)
# Remove any 'unused' timing timplates/waveforms from the output file, if true.
tdl_purge_unused_timing = 0

# Drive off position. (Optional, default = 0ns)
# Valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
tdl_drive_off_position = ''

# Signal drive off position. (Optional)
# Pin to position map
# Position valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
# tdl_signal_drive_off_position = { 'data' : '2ns'}

##############################
# ATE Generator Configuration
######

# Target Platform.(Mandatory)
# Valid values depend on configuration file installed.
# Currently available targets:
#  "93000DD"
#  "93000SD"
#  "93000SS"
#  "CredenceQuartet"
#  "EagleEVD"
#  "EagleSTIL"
target = 'CredenceQuartet'

# Additional pattern comment.
# This comment will be added to the first vector of all patterns.
pattern_comment = ''

# Default definition files.(Optional)
# Files containing STIL blocks with default definitions.
default_definitions = []

# External data files.(Optional)
# Files containing additional STIL blocks.
external_data_files = []

# STIL PatternExec name. (Optional)
# First one is used if not specified.
stil_pattern_exec = ''

# Pattern naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_pattern_name = 0, use STIL Pattern name when generating pattern.
# If stil_file_name_as_pattern_name = 1, use STIL File name.
stil_file_name_as_pattern_name = 0

# Project naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_project_name = 0, use project_name parameter as a base name for signal, timing, levels etc. files.
# If stil_file_name_as_project_name = 1, use STIL File name.
stil_file_name_as_project_name = 0

# Use STIL file name as WFT prefix ( Optional, default = 0 ).
stil_file_name_as_wft_prefix = 0

# Label suffix flag ( Optional, default =  ).
# Add custom suffix to all pattern and burst names
label_suffix = ""

# Set ScanIn signals padding value ( Optional, default = '0' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanin = '0'

# Set ScanOut signals padding value ( Optional, default = 'X' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanout = 'X'

# Alternative WFC Map. (Optional)
# Define alternative WFC Map for data assignment conflict resolution.
# This map will only be used if native STIL WFCMap fails to resolve a conflict.
# Example: { '0X' : '0', '1X' : '1', ...   }
stil_wfc_map = {
    }

# Global STIL Action Map. (Optional)
# Allows users to globally remap STIL action states in Timing section.
# Example: { 'Z': 'X', 'P': D' }
stil_action_map = { }

# Exit with an error if signal is assigned the value twice in the same vector
# and WFCMap is either absent or does not resolve the ambiguity. (Optional, default is 0).
error_on_2_state_ambiguity = 0

# Force edge strobe ( Optional, default = 0 ).
# If set to 1, STIL window compare events will be replaced with edge compare.
# If set to 0, STIL window compare events will be kept.
force_edge_strobe = 0

# Generate complementary waveforms ( Optional, default = 0 ).
# If set to 1, additional waveforms with "complementary" actions will be generated:
# - for each single-drive   waveform - new ForceUp/Down waveforms
# - for each single-compare waveform - new CompareHigh/Low/Off/Unknown waveforms.
generate_complementary_waveforms = 0

# STIL resource tags handling configuration ( Optional, default = 0 ).
# If ignore_stil_rtags = 1, STIL <rtag> data will be stored and possibly used ( target dependent ).
# If ignore_stil_rtags = 0, STIL <rtag> data will be ignored.
ignore_stil_rtags = 0

# STIL ScanStructures handling configuration ( Optional, default = 1 ).
# If ignore_scan_structures = 0, STIL ScanStructures data will be stored and possibly used ( target dependent ).
# If ignore_scan_structures = 1, STIL ScanStructures data will be ignored.
ignore_scan_structures = 1

# STIL Pseudo Signals handling configuration ( Optional, default = 1 ).
# If stil_ignore_pseudo_signals = 0, Signals of type Pseudo will be processed similar to other signals.
# If stil_ignore_pseudo_signals = 1, Signals of type Pseudo will be ignored.
stil_ignore_pseudo_signals = 1


# Output directory. (Optional, default = 'output')
workdir = 'output'

# Project name. (Optional, default = 'project' )
# Serves as a base name for all named TP blocks
project_name = ''

# Pattern signals definition. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Define a reduced set signals to be used in the pattern only.
# Signals not in the list will still appear in 'workspace' portion
# of the test program.
# Example: [ 'sig1', 'sig2', 'sigN' ]
pattern_signals = [  ]

# Define global signals set. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Only specified signals will be passed to the target test program.
# This parameter is mutually exclusive with 'exclude_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
include_signals = [  ]

# Define set of signals to exclude from target test program. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Specified signals will be completely removed from the target test program.
# This parameter is mutually exclusive with 'include_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
exclude_signals = [  ]

# Rename signals. (Optional)
# Define a mapping between simulation signals and target ATE pins.
# Any signals not specified in the map will use original names.
# Signal groups are not allowed.
# Note: this will not affect any signal-related configuration settings above,
#       i.e. all signal-related setup variables should always refer to the original signal names.
# Example: { 'signal_name1' : 'ATE_signal_name1', 'signal_name2' : 'ATE_signal_name2', ...   }
rename_signals = {

}

# Stop on uninitialized signals ( Optional, default = 0 ).
stop_on_uninitialized_signals = 0

# Rename WFTs. (Optional)
# Define a mapping between simulation WFTs and target ATE WFTs.
# Example: { 'WFT1' : 'ATE_WFT1', 'WFT2' : 'ATE_WFT2', ...   }
rename_wfts = {
    }

# Timing Map. (Optional)
# Define STIL timing mapping in order to fit to tester restrictions.
# For example, map all dual compare waveforms to single compare.
# By default all inputs with undefined value are mapped to 0.
# The following wildcards can be used:
#     I for input  actions - D, U, P, A, B
#     O for output actions - H, L, X, x, T, V, l, h, t, v
#     . for any action.
# Example: { 'N' : 'D' }
timing_map = {
    'N': 'D',
    }

# Signal Timing Map. (Optional)
# Define STIL timing mapping for specific signals.
# By default global timing map is used.
# Wildcards can be used (same as in Timing Map).
# Example: { 'STIL_signal_name1' : { 'UDU' : '-DU' , 'DUD' : '-UD' , ... } , ... }
signal_timing_map = {
    }

# Sequence Map. (Optional)
# Define pattern states mapping for specific signals.
# Valid values are 0/1/Z/L/H/T/X.
# Example: { 'signal_name1' : { '010' : '111' , 'LHL' : 'LXL' , ... } , ... }
sequence_map = {
    }

# Equation Based Timing. (Optional, default = 1)
# Generate equation (Spec) based timing if original timing only used absolute values without any Spec definition.
# For example, equation specified as 10ns (when period is 100ns)
# will become 0.1*per_100, where per_100 is a new Spec variable.
equation_based_timing = 1

# Optimize Spec Variables in Equation Based Timing Mode. (Optional, default = 1)
# If optimize_equation_based_timing_vars = 1, a spec variable for each unique WFT period will be generated (e.g. per_100).
# If optimize_equation_based_timing_vars = 0, a spec variable for each WFT will be generated (e.g. per_SHIFT, per_CAPTURE).
optimize_equation_based_timing_vars = 1

# Define Muxed Signals List.(Optional)
# Both signals and signal groups alowed ( groups are expanded ).
# Wildcards allowed ( only '?' and '*' supported ).
# Second signal name will be composed as [signal name][mux_signal_suffix].
# Note: Second (muxed) signal must not exist in original signals list.
# Example: [ 'sig1', 'sig2', 'sigN' ]
generate_mux_signals = [  ]

# Muxed signal suffix. (Optional, default = '_mux')
# Used in conjunction with 'generate_mux_signals' to form second signal name.
mux_signal_suffix = '_mux'

# Vector Comment Source. ( Optional, default = ['Annotation'] )
# Vector comment is placed before the vector call in the vector comment field, as follows:
# 'Annotation' use the content of the annotation block ( Ann {* .. *} )
# 'C' use the content of the C comment ( /* .. */ )
# 'C++' use the content of the C++ comment ( // ... )
# 'Macro' Places name of Macro called in the vector comment field
# 'Procedure' Places name of Procedure called in the vector comment field.
# 'Scan Instance' Places the scan instance in the vector comment field (i.e. the number of times the Shift
#                 statement has been called in the context of a Pattern block)
# 'Label' Places STIL Label name in the vector comment field
#  Note: more the one comment type may be defined, as follows: [ 'C', 'C++', 'Macro' ]
vector_comment_source = [ 'C++', 'C', 'Annotation' ]

# Same line comment handling. ( Optional, default = 0 )
# If set to 1, attach comment to the vector at the same line.
# If set to 0, attach it to the next vector
same_line_comment = 0

# Define set of scan cells to mask. (Optional)
# Example: [ 'cell1', 'cell2', 'cellN' ]
mask_scan_cells = [  ]

# Define set of scan chains to mask. (Optional)
# Example: [ 'chain1', 'chain2', 'chainN' ]
mask_scan_chains = [  ]

# Define set of scan signals to mask. (Optional)
# Example: [ 'sig1', 'sig2', 'sigN' ]
mask_scan_signals = [  ]

# Scan pattern start label. (Optional, default = '')
# Generation of scan pattern will start from this label.
# If empty, generation starts at the start of the pattern.
scan_pattern_start = ''

# Scan pattern stop label. (Optional, default = '')
# Generation of scan pattern will stop at this label.
# If empty, generation stops at the end of the pattern.
scan_pattern_stop = ''

# Skip non-indexed multibit events. (Optional, default = 1)
# In multibit waveforms, use only indexed events when creating wfc sequence.
# For example, waveform "eE {'0ns' D/U[0]; '2.5ns' Z; }"
# should be referred in pattern as e or E (if parameter is set to 1).
# or as ee or Ee (if parameter is set to 0).
skip_nonindexed_events = 1

# Define set of user keywords to be processed. (Optional)
# The following keywords can be specified:
# 'ShiftIncrement': similar to Shift, but if contains multiple vectors, data is shifted after each vector
#                   (no need to specify, supported by default)
# 'InfiniteLoop'  : handled as non-looped sequence of vectors
# Example: [ 'kwd1', 'kwd2' ]
process_user_keywords = [  ]

# Generate pins ( Optional, default = 1 ).
# If set to 1, ATE pin definitions will be generated.
# If set to 0, ATE pin generation will be skipped ( target dependent ).
generate_pins = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE timing definitions will be generated.
# If set to 0, ATE timing generation will be skipped ( target dependent ).
generate_timing = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE DC levels definitions will be generated.
# If set to 0, ATE DC levels generation will be skipped ( target dependent ).
generate_levels = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE patterns will be generated.
# If set to 0, ATE patterns generation will be skipped ( target dependent ).
generate_patterns = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE workspace will be generated.
# If set to 0, ATE workspace generation will be skipped ( target dependent ).
generate_workspace = 1

############################
# Virtual Signal Generation
#

# Define virtual signals ( optional ).
#  Attributes:
#   name:	 virtual signal name ( mandatory, must be unique )
#   type:	 virtual signal type ( optional, one of [ In | Out | InOut ] )
#   opcode:	 virtual signal operator ( mandatory )
#     'Fixed':            Fixed state signal ( arg1 = state [DUZLHXT], arg2 = time )
#     'Copy':             Copy reference signal ( arg1 = ref. signal name )
#     'Not':              Copy reference signal, inverting states ( arg1 = ref. signal name )
#   args:	 operator attributes ( depend on 'op' selected )
#
# virtual_signals = [ 
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] },
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] } ...
# ]

##################################
# CredenceQuartet flags 
######

# Credence Quartet flags

# Generate timing using AC spec expressions, if available
# If disabled, absolute timing values will be used
quartet_use_equations = 1

# Automatic timing grouping for pins sharing the same timing information
# Try to generate groups from the remaining signals (default is 1) 
quartet_use_tim_groups = 1

# Allow midband value sampling.
# If disabled, midband compare states will be masked
quartet_midband_sampling = 0

# Custom pattern header
quartet_custom_header = ''

# Generate "control loop_pack" statement
quartet_loop_pack = 0

# Maximum repeat count in vectors
quartet_max_repeat_count = 4095

# Expand loops in vectors
quartet_expand_loops = 0

# Use scan option for vectors.
# If scan option is not used, scan vectors 
# will be automatically expanded into plain vectors.
quartet_create_scan_vectors = 0

